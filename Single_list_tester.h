/*************************************************
 * Single_list_tester<Object>
 * A class for testing singly-linked lists.
 *
 * Author:  Douglas Wilhelm Harder
 * Copyright (c) 2006-2010 by Douglas Wilhelm Harder.  All rights reserved.
 *
 * DO NOT EDIT THIS FILE
 *************************************************/

#ifndef SINGLE_LIST_TESTER_H    // include guards
#define SINGLE_LIST_TESTER_H

#include "Exception.h"
#include "Tester.h"
#include "Single_list.h"
#include "Single_node.h"
#include "Single_node_tester.h"

#include <iostream>

template <typename Object>
class Single_list_tester:public Tester< Single_list<Object> > {
	using Tester< Single_list<Object> >::object;
	using Tester< Single_list<Object> >::command;

	public:
		Single_list_tester( Single_list<Object> *obj = 0 ):Tester< Single_list<Object> >( obj ) {
			// empty
		}

		void process();
};

/****************************************************
 * void process()
 *
 * Process the current command.  For singly-linked lists, these include:
 *
 *  Accessors
 *
 *   size n          size            the size equals n
 *   empty b         empty           the result is the boolean value b
 *   front n         front           n is the first element in the linked list
 *   front!          front           the underflow exception is thrown
 *   back n          back            n is the last element in the linked list
 *   back!           back            the underflow exception is thrown
 *   head            head            the head is not 0 and starts a Single_node_tester on that
 *                                   node until the 'exit' command is typed
 *   head0           head            the head is 0
 *   tail            tail            the tail is not 0 and starts a Single_node_tester on that
 *                                   node until the 'exit' command is typed
 *   tail0           tail            the tail is 0
 *   count n m       count           the number of occurances of n is m
 *
 *  Mutators
 *
 *   push_front n    push_front      the element can be pushed onto the front (always succeeds)
 *   push_back n     push_back       the element can be pushed onto the back (always succeeds)
 *   pop_front n     pop_front       the front element can be popped and equals n
 *   pop_front!      pop_front       the underflow exception is thrown
 *   erase n m       erase           the number of erased occurances of n is m
 *
 *  Others
 *   cout            cout << list    print the list (for testing only)
 *   assign          operator =      assign this list to a new list
 *   summary                         prints the amount of memory allocated
 *                                   minus the memory deallocated
 *   details                         prints a detailed description of which
 *                                   memory was allocated with details
 *
 ****************************************************/

template <typename Object>
void Single_list_tester<Object>::process() {
	if ( command == "size" ) {
		// check if the size equals the next integer read

		int expected_size;

		std::cin >> expected_size;

		int actual_size = object->size();

		if ( actual_size == expected_size ) {
			std::cout << "Okay" << std::endl;
		} else {
			std::cout << "Failure in size(): expecting the value '" << expected_size << "' but got '" << actual_size << "'" << std::endl;
		}
	} else if ( command == "empty" ) {
		// check if the empty status equals the next boolean read

		bool expected_empty;

		std::cin >> expected_empty;

		bool actual_empty = object->empty();

		if ( actual_empty == expected_empty ) {
			std::cout << "Okay" << std::endl;
		} else {
			std::cout << "Failure in empty(): expecting the value '" << expected_empty << "' but got '" << actual_empty << "'" << std::endl;
		}
	} else if ( command == "front" ) {
		// checks if the first object in the linked list equals the next object read

		Object expected_front;

		std::cin >> expected_front;

		Object actual_front = object->front();

		if ( actual_front == expected_front ) {
			std::cout << "Okay" << std::endl;
		} else {
			std::cout << "Failure in front(): expecting the value '" << expected_front << "' but got '" << actual_front << "'" << std::endl;
		}
	} else if ( command == "front!" ) {
		// front of an empty list - catch an exception

		Object actual_front;

		try {
			actual_front = object->front();
			std::cout << "Failure in front(): expecting to catch an exception but got '" << actual_front << "'" << std::endl;
		} catch( underflow ) {
			std::cout << "Okay" << std::endl;
		} catch (...) {
			std::cout << "Failure in front(): expecting an underflow exception but caught a different exception" << std::endl;
		}
	} else if ( command == "back" ) {
		// checks if the last object in the linked list equals the next object read

		Object expected_back;

		std::cin >> expected_back;

		Object actual_back = object->back();

		if ( actual_back == expected_back ) {
			std::cout << "Okay" << std::endl;
		} else {
			std::cout << "Failure in back(): expecting the value '" << expected_back << "' but got '" << actual_back << "'" << std::endl;
		}
	} else if ( command == "back!" ) {
		// back of an empty list - catch an exception

		Object actual_back;

		try {
			actual_back = object->back();
			std::cout << "Failure in back(): expecting to catch an exception but got '" << actual_back << "'" << std::endl;
		} catch( underflow ) {
			std::cout << "Okay" << std::endl;
		} catch (...) {
			std::cout << "Failure in back(): expecting an underflow exception but caught a different exception" << std::endl;
		}
	} else if ( command == "head" ) {
		// checks that the head is not 0, and if it is not,
		// the next object gives the number of commands which should
		// be tested by the Single_node_tester

		Single_node<Object> *actual_head = object->head();

		if ( actual_head == 0 ) {
			std::cout << "Failure in head(): expecting a non-zero head pointer" << std::endl;
		} else {
			std::cout << "Okay" << std::endl;

			Single_node_tester<Object> tester( actual_head );

			tester.run();
		}
	} else if ( command == "head0" ) {
		// check that the head pointer is 0

		if ( object->head() == 0 ) {
			std::cout << "Okay" << std::endl;
		} else {
			std::cout << "Failure in head(): expecting a 0 head pointer" << std::endl;
		}
	} else if ( command == "tail" ) {
		// checks that the tail is not 0, and if it is not,
		// the next object gives the number of commands which should
		// be tested by the Single_node_tester

		Single_node<Object> *actual_tail = object->tail();

		if ( actual_tail == 0 ) {
			std::cout << "Failure in tail(): expecting a non-zero tail pointer" << std::endl;
		} else {
			std::cout << "Okay" << std::endl;

			Single_node_tester<Object> tester( actual_tail );

			tester.run();
		}
	} else if ( command == "tail0" ) {
		// check that the tail pointer is 0

		if ( object->tail() == 0 ) {
			std::cout << "Okay" << std::endl;
		} else {
			std::cout << "Failure in tail(): expecting a 0 tail pointer" << std::endl;
		}
	} else if ( command == "count" ) {
		// check if the next object read in is in the linked list

		Object element;
		int expected_count;

		std::cin >> element;
		std::cin >> expected_count;

		if ( object->count( element ) == expected_count ) {
			std::cout << "Okay" << std::endl;
		} else {
			if ( expected_count == 1 ) {
				std::cout << "Failure in count(): expecting the value '" << element << "' to be in the linked list" << std::endl;
			} else {
				std::cout << "Failure in count(): not expecting the value '" << element << "' to be in the linked list" << std::endl;
			}
		}
	} else if ( command == "push_front" ) {
		// push the next object read to the front of the linked list

		Object n;

		std::cin >> n;

		object->push_front( n );
		std::cout << "Okay" << std::endl;
	} else if ( command == "push_back" ) {
		// push the next object read to the back of the linked list

		Object n;

		std::cin >> n;

		object->push_back( n );
		std::cout << "Okay" << std::endl;
	} else if ( command == "pop_front" ) {
		// pop the first object from the linked list

		Object expected_popped_element;

		std::cin >> expected_popped_element;

		Object actual_popped_element = object->pop_front();

		if ( actual_popped_element == expected_popped_element ) {
			std::cout << "Okay" << std::endl;
		} else {
			std::cout << "Failure in pop_front(): expecting the value '" << expected_popped_element << "' but got '" << actual_popped_element << "'" << std::endl;
		}
	} else if ( command == "pop_front!" ) {
		// pop from an empty list - catch an exception

		Object actual_popped_element;

		try {
			actual_popped_element = object->pop_front();
			std::cout << "Failure in pop_front(): expecting to catch an exception but got '" << actual_popped_element << "'" << std::endl;
		} catch( underflow ) {
			std::cout << "Okay" << std::endl;
		} catch (...) {
			std::cout << "Failure in pop_front(): expecting an underflow exception but caught a different exception" << std::endl;
		}
	} else if ( command == "erase" ) {
		Object n;
		int expected_count;

		std::cin >> n;
		std::cin >> expected_count;

		int actual_count = object->erase( n );

		if ( actual_count == expected_count ) {
			std::cout << "Okay" << std::endl;
		} else {
			std::cout << "Failure in erase( " << n << " ): expecting the value '" << expected_count << "', but got " << actual_count << std::endl;
		}
	} else if ( command == "assign" ) {
		Single_list<Object> *new_object = new Single_list<Object>();

		*new_object = *object;

		std::cout << "Okay" << std::endl;

		Single_list_tester<Object> tester( new_object );

		tester.run();
	} else if ( command == "cout" ) {
		std::cout << *object << std::endl;
	} else {
		std::cout << command << "Command not found." << std::endl;
	}
}

#endif
